<h1>数独问题中文说明（均用伪代码，别在意用的语言，看懂就好啦）</h1>
<p>这是回溯问题的一个讲解，回溯问题分为：递推和递归。
    首先我们是有很多选项，一旦满足，开始递推；一旦不满足，在这个步骤换个选项继续推导（这里是推导，意思是看满不满足，满足就递推），当所有的选项都用完了，说明没有选择了，说明上一个步骤有问题就递归回去。<b>（递归回去，换一种方法继续递归）</b>
    比如连锁填空【】【】【】（选择1，2，3），如果【1】满足，我们走下一步【1】【1】，显然第二个1不满足，我们就换另外一种选项【1】【2】....，类似的，当第二个选项1，2，3都不符合，我们就回到上一个步骤去把第一步的1给改了。
</p>
<h2>现在我们来谈谈数独问题</h2>
<p>首先认识到，每一个i，j行这样的参数不好传入，那我们就把这个问题当作0-80的一个数组，然后i可以从80整除9得出，j可以从80余9得出,所以这个问题我们从n=0开始走，条件满足我们走下一步，所以我们要懂得，只有条件满足n才会+1，条件都不满足我们就会回溯上去。所以当我们执行到n>80(因为n==80还是在数组里，80+1 才是走完所有哦~)，我们的数独就走完了，这个时候打印数独数组就是我们要的答案。因为设立一个条件:   if(n>80): printf(array) </p>
<p>我们还要判断一下是否满足条件的函数，因为数独是这一行，这一列，这一个正方形里不能有重复的数字，所以前两个条件相对简单好写，传入参数i,j 首先这一行就是i不变，遍历0-9列；然后就是j不变，遍历0-9行。有些难度的是正方形，我们注意一下，我们把9*9方格看作3*3部分，每一个部分的开头是（0，0），（0，3），（0，6），（3，0）...... 得出我们把i整除3再乘3就得到了开头部分，把j整除3再乘3也可以得到，最后这个正方形的范围是 int(i/3)--int(i/3+3),int(j/3)--int(j/3+3)，所以在这个范围内，我们判断是否存在重复，如果有，return false，当所有的的条件都判断都不是false，说明这个数字是满足的，return true</p>
<p><b><u>重要的一步</u>完成了判断这一函数，我们处理sudoku(n)这个回溯函数，从n==0这一步骤开始，分两条路，如果n>80，则打印，因为都满足了数独的rule，如果n小于80，说明还要继续填写，一些空格是写好了的数字，我们不用管，当遇到空的格子（代码里是'.'），我们需要从1-9中选一个数字，所以我们必须一个个都要试过去，这里用for循环来尝试1-9是否满足，如果1满足，先让这个空格为‘1’，再做下一步骤 n+1,sudoku(n+1),因为这样我们是在这个空格为‘1’的条件下，走下一步的。如果所有的选项都失败了，说明前一步的1是错误的，我们就使这个空格重新变为‘.’，然后再试其他的选项。为什么呢？回溯问题的连锁反应，如果我们不设为‘.’,回去的时候错误的1就一直停留再那里，如果很早很早的步骤a也是错的，那么这个1我们称为步骤b，b是在a的错误下而错误，如果不让b变为‘.’,那么有可能1在步骤a是对的，但是b占着这个位置a步骤就不能改为1，就会导致问题无法得到解决</b></p>
<p>主要还是说明一下这个算法的思想和代码思想，嘻嘻</p>